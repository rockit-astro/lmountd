#!/usr/bin/env python3.6
#
# This file is part of lmountd.
#
# lmountd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# lmountd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with lmountd.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for controlling a Planewave L mount through its http interface via Pyro"""

import argparse
import threading
from astropy.coordinates import SkyCoord, EarthLocation, get_moon, get_sun
from astropy.time import Time
import astropy.units as u
import requests
import Pyro4

from warwick.observatory.common import log, TryLock
from warwick.observatory.common.helpers import pyro_client_matches
from warwick.observatory.lmount import CommandStatus, Config, MountState

# Set automatically when generating RPM package
SOFTWARE_VERSION = "UNKNOWN"


def _parse_mountstate(status):
    """Determine the current MountState value based on the PWI status dictionary and other state"""
    if status['mount.is_connected'] != 'true':
        return MountState.Disabled

    # Simplify the external API we expose by also treating unpowered axes as disabled
    if status['mount.axis0.is_enabled'] != 'true' or status['mount.axis1.is_enabled'] != 'true':
        return MountState.Disabled

    if status['mount.is_slewing'] == 'true':
        return MountState.Slewing

    if status['mount.is_tracking'] == 'true':
        return MountState.Tracking

    return MountState.Stopped


class MountDaemon:
    """Daemon interface for talon subsystems"""
    def __init__(self, config):
        self._config = config

        # PWI doesn't force the mount to be homed between powering on and operation.
        # Force this requirement through the daemon instead.
        self._is_homed = False

        # Only one command may be active at a time (except for stop)
        self._command_lock = threading.Lock()

    def _request_with_status(self, command, **kwargs):
        """
        Send a command to PWI4 and return its status response
        Returns None if the command failed or a dictionary of the mount status
        """
        try:
            url = 'http://{}:{}/{}'.format(self._config.pwi_host, self._config.pwi_port, command)
            response = requests.get(url, timeout=self._config.pwi_timeout, params=kwargs)
            response.raise_for_status()

            data = response.text.split("\n")
            status = {}
            for line in data:
                fields = line.split("=", 1)
                if len(fields) == 2:
                    status[fields[0]] = fields[1]
            return status
        except Exception:
            return None

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current telescope state"""

        status = self._request_with_status('status')
        if status is None:
            return {
                'date': Time.now().strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
                'state': MountState.Disabled,
                'state_label': MountState.label(MountState.Disabled),
                'software_version': SOFTWARE_VERSION,
            }

        # There is a small amount of latency between the axis times and the status request
        # Assume that the RA axis is the most representative time for the calculated data
        location = EarthLocation(
            lat=status['site.latitude_degs'],
            lon=status['site.longitude_degs'],
            height=status['site.height_meters'])

        state = _parse_mountstate(status)

        # Prefer the mount timestamp if we have it - this was when the coordinates were calculated
        # If the mount is not connected we can safely fall back to the request timestamp
        if state == MountState.Disabled:
            timestamp = status['response.timestamp_utc']
        else:
            timestamp = status['mount.timestamp_utc']

        date = Time(Time.strptime(timestamp, '%Y-%m-%d %H:%M:%S.%f'), location=location)
        data = {
            'date': date.strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
            'state': state,
            'state_label': MountState.label(state),
            'software_version': SOFTWARE_VERSION,
            'pwi_version': status['pwi4.version'],
            'site_latitude': location.lat.to_value(u.deg),
            'site_longitude': location.lon.to_value(u.deg),
            'site_elevation': location.height.to_value(u.m),
        }

        if state != MountState.Disabled:
            lst = u.Quantity(status['site.lmst_hours'], unit=u.hourangle)

            data.update({
                'lst': lst.to_value(u.deg),
                'axes_homed': self._is_homed
            })

            if state >= MountState.Stopped:
                pointing = SkyCoord(
                    ra=status['mount.ra_j2000_hours'],
                    dec=status['mount.dec_j2000_degs'],
                    unit=(u.hourangle, u.deg),
                    frame='icrs')

                data.update({
                    'ra': pointing.ra.to_value(u.deg),
                    'dec': pointing.dec.to_value(u.deg),
                    'offset_ra': 0,
                    'offset_dec': 0,

                    # Note: this field depends on a custom patched version of pwi4
                    'ha': u.Quantity(status['mount.ha_hours'], unit=u.hourangle).to_value(u.deg),

                    'alt': u.Quantity(status['mount.altitude_degs'], unit=u.deg).to_value(u.deg),
                    'az': u.Quantity(status['mount.azimuth_degs'], unit=u.deg).to_value(u.deg),

                    'moon_separation': get_moon(date).separation(pointing).to_value(u.deg),
                    'sun_separation': get_sun(date).separation(pointing).to_value(u.deg),
                })

        return data

    @Pyro4.expose
    def find_homes(self):
        """Finds the mount home positions"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            status = self._request_with_status('status')
            state = _parse_mountstate(status)
            if state == MountState.Disabled:
                return CommandStatus.MountNotInitialized

            if state != MountState.Stopped:
                return CommandStatus.MountNotStopped

            log.info(self._config.log_name, 'Homing axes')
            if self._request_with_status('mount/find_home') is None:
                log.error(self._config.log_name, 'Failed to issue home command')
                return CommandStatus.Failed

            # Wait for up to 1 minute for the mount to stop slewing
            # TODO: What happens if we issue a stop while homing?
            for _ in range(60):
                status = self._request_with_status('status')
                state = _parse_mountstate(status)
                if state != MountState.Slewing:
                    break

            # TODO: How do we know if this succeeded?
            # TODO: Investigate what happens with the real hardware!
            if state == MountState.Slewing:
                log.error(self._config.log_name, 'Homing failed')
                self._request_with_status('mount/stop')
                return CommandStatus.Failed

            log.info(self._config.log_name, 'Homing complete')

            self._is_homed = True
            return CommandStatus.Succeeded

    @Pyro4.expose
    def initialize(self):
        """Connect to mount and enable motor power"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            status = self._request_with_status('status')
            if status is None:
                return CommandStatus.MountControlNotRunning

            state = _parse_mountstate(status)
            if state != MountState.Disabled:
                return CommandStatus.MountNotDisabled

            if self._request_with_status('mount/connect') is None:
                log.error(self._config.log_name, 'Failed to connect to mount')
                return CommandStatus.Failed

            # TODO: This may happen automatically on connect, check with the real hardware!
            if self._request_with_status('mount/enable', axis=-1) is None:
                log.error(self._config.log_name, 'Failed to enable motor power')
                return CommandStatus.Failed

            self._is_homed = False

            # Double check that things are now how we expect
            status = self._request_with_status('status')
            state = _parse_mountstate(status)

            return CommandStatus.Failed if state == MountState.Disabled else CommandStatus.Succeeded

    @Pyro4.expose
    def shutdown(self):
        """Disables motor power and disconnects from mount"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            status = self._request_with_status('status')
            state = _parse_mountstate(status)
            if state == MountState.Disabled:
                return CommandStatus.MountNotInitialized

            # TODO: This may happen automatically on disconnect, check with the real hardware!
            if self._request_with_status('mount/disable', axis=-1) is None:
                log.error(self._config.log_name, 'Failed to disable motor power')
                return CommandStatus.Failed

            if self._request_with_status('mount/disconnect') is None:
                log.error(self._config.log_name, 'Failed to disconnect from mount')
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    # pylint: disable=no-self-use
    @Pyro4.expose
    def ping(self):
        """Returns immediately with a success status"""
        return CommandStatus.Succeeded
    # pylint: enable=no-self-use


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Telescope Server')
    parser.add_argument('config', help='Path to configuration json file')
    args = parser.parse_args()
    c = Config(args.config)
    c.daemon.launch(MountDaemon(c))
